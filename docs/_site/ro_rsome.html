<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="icon" type="image/png"  href="assets/img/favicon.png">
    <title>RSOME in Python by XiongPengNUS</title>

    <link rel="stylesheet" href="/assets/css/styles.css?v=1133c49022053655fa92e79972cc63c5f2737f41">
    <meta name="viewport" content="width=device-width">

    <!-- Place this tag in your head or just before your close body tag. -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
  </head>
  <body>
    <div class="wrapper">
      <header>

        
          <img src="/rso_left.png" alt="Logo" width=180/>
        

        <h1>RSOME in Python</h1>

        <table>
          <tr>
          <td><a class="github-button" href="https://github.com/XiongPengNUS/road" data-show-count="true" aria-label="Star XiongPengNUS/road on GitHub">Star</a></td>
          <td><a class="github-button" href="https://github.com/XiongPengNUS/road/subscription" data-show-count="true" aria-label="Watch XiongPengNUS/road on GitHub">Watch</a></td>
          <td><a class="github-button" href="https://github.com/XiongPengNUS/road/fork" data-show-count="true" aria-label="Fork XiongPengNUS/road on GitHub">Fork</a></td>
          </tr>
        </table>

        <table>
          
            
              <tr><th><a href="/">Home</a></th></tr>
            
          
            
              <tr><th><a href="/user_guide">User Guide</a></th></tr>
            
          
            
              <tr><th><a href="/examples">Examples</a></th></tr>
            
          
            
              <tr><th><a href="/about">About</a></th></tr>
            
          
        </table>

        
          <ul>
            <li><a href="https://github.com/XiongPengNUS/rsome/zipball/gh-pages">Download <strong>ZIP File</strong></a></li>
            <li><a href="https://github.com/XiongPengNUS/rsome/tarball/gh-pages">Download <strong>TAR Ball</strong></a></li>
            <li><a href="https://github.com/XiongPengNUS/rsome">View On <strong>GitHub</strong></a></li>
          </ul>
        

      </header>
      <section>

      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>

<h1 id="rsome-for-robust-optimization">RSOME for Robust Optimization</h1>

<h2 id="general-formulation-for-robust-optimization-models-">General Formulation for Robust Optimization Models <a name="section2.1"></a></h2>

<p>The <code class="language-plaintext highlighter-rouge">rsome.ro</code> module in RSOME is designed for robust optimization problems, where tailored modeling tools are developed for specifying random variables, uncertainty sets, and objective functions or constraints under worst-case scenarios that may arise from the uncertainty set. Let \(\pmb{z}\in\mathbb{R}^J\) be a vector of random variables and \(\pmb{x}\in\mathbb{R}^{I_x}\)(resp., \(\pmb{y}(\pmb{z})\in\mathbb{R}^{I_y}\)) be the here-and-now  (resp., non-anticipative wait-and-see) decision made before (resp., after) the uncertainty realizes. Models supported in the <code class="language-plaintext highlighter-rouge">ro</code> module can be cast into the following general format:</p>

\[\begin{align}
\min ~ &amp;\max\limits_{\pmb{z}\in\mathcal{Z}_0} ~\left\{\pmb{a}_0^{\top}(\pmb{z})\pmb{x} + \pmb{b}_0^{\top}\pmb{y}(\pmb{z}) + c_0(\pmb{z})\right\} &amp;&amp;\\
\text{s.t.} ~ &amp; \max\limits_{\pmb{z}\in\mathcal{Z}_M}\left\{\pmb{a}_m^{\top}(\pmb{z})\pmb{x} + \pmb{b}_m^{\top}\pmb{y}(\pmb{z}) + c_m(\pmb{z})\right\} \leq 0, &amp;&amp; \forall m \in \mathcal{M}_1 \\
&amp; y_i \in \mathcal{L}(\mathcal{J}_i) &amp;&amp;\forall i \in [I_y] \\
&amp; \pmb{x} \in \mathcal{X}. &amp;&amp;
\end{align}\]

<p>Here \(\mathcal{X}\subseteq \mathbb{R}^{I_x}\) is a feasible of \(\pmb{x}\) which is second-order conic or exponential conic representable, \(\pmb{b}_m\in\mathbb{R}^{I_y}\), \(m \in \mathcal{M}_1 \cup \{0\}\) are fixed parameters of \(\pmb{y}\), and uncertain parameters \(\pmb{a}_m(\pmb{z})\) as well as \(c_m(\pmb{z})\) are expressed as affine mappings of random variable \(\pmb{z}\):</p>

\[\begin{align}
\pmb{a}_m(\pmb{z}) := \pmb{a}_m^0 + \sum\limits_{j\in[J]}\pmb{a}_m^jz_j ~~\text{and}~~ c_m(\pmb{z}) := c_m^0 + \sum\limits_{j\in[J]}c_m^jz_j.
\end{align}\]

<p>where \(\pmb{a}_m^j\in\mathbb{R}^{I_x}\) and \(c_m^j\in\mathbb{R}\), indexed by \(j\in[J]\cup\{0\}\) and \(\mathcal{M}_1\cup \{0\}\), are proper coefficients. The wait-and-see decision \(\pmb{y}\), which can potentially be an arbitrary functional of uncertainty realization \(\pmb{z}\), is infinite-dimensional, and thus is hard to optimize. A common robust optimization technique for tractability, called linear decision rule (or affine decision rule), is to restrict y to simpler and easy-to-optimize affine functions in the following form:</p>

\[\begin{align}
\mathcal{L}(\mathcal{J}) := \left\{y: \mathbb{R}^{[\mathcal{J}]} \mapsto \mathbb{R} \left|
y(\pmb{z}) = y^0 + \sum\limits_{j\in\mathcal{J}}y^jz_j
\right.
\right\}.
\end{align}\]

<p>The RSOME package provides rich algebraic tools for specifying random variables arrays, linear decision rules, uncertainty sets, the worst-case objective and constraints of a robust model, which will be introduced in the subsequent sections.</p>

<h2 id="random-variables-and-uncertainty-sets-">Random Variables and Uncertainty Sets <a name="section2.2"></a></h2>

<p>Similar to decision variables, random variables are created as arrays in RSOME, and the shapes of random variable arrays are specified by the <code class="language-plaintext highlighter-rouge">rvar()</code> method of the <code class="language-plaintext highlighter-rouge">Model</code> object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rvar(shape=(1,), name=None) method of rsome.ro.Model instance
    Returns an array of random variables with the given shape.

    Parameters
    ----------
    shape : int or tuple
        Shape of the variable array.
    name : str
        Name of the variable array

    Returns
    -------
    new_var : rsome.lp.Vars
        An array of new random variables
</code></pre></div></div>

<p>All array operations, convex functions, and NumPy-style syntax for decision variables can also be applied to random variables in defining uncertainty sets. For example, let \(\pmb{z}\in\mathbb{R}^5\) be the vector of random variables, an uncertainty set \(\mathcal{Z}_0 = \{ \pmb{z} \left| |\pmb{z}|_{\infty}\leq 1 , |\pmb{z}|_1 \leq 1.5 \right.\}\) can be defined as <code class="language-plaintext highlighter-rouge">z_set0</code> in the following code segment.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>
<span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>                 <span class="c1"># create a model object
</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                  <span class="c1"># 5 random variables as an 1D array
</span>
<span class="n">z_set0</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>    <span class="c1"># the infinity-norm constraint
</span>          <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.5</span><span class="p">)</span>       <span class="c1"># the one-norm constraint
</span></code></pre></div></div>

<p>Note that an uncertainty set is a collection of constraints, written as an iterable Python object, such as <code class="language-plaintext highlighter-rouge">tuple</code> or <code class="language-plaintext highlighter-rouge">list</code>. These constraints are then used in specifying the worst-case objective function and constraints, which are introduced in the next section.</p>

<h2 id="the-worst-case-objective-and-constraints-">The Worst-Case Objective and Constraints <a name="section2.3"></a></h2>

<p>In the case of minimizing or maximizing the worst-case objective function in ROMSE, we may use the <code class="language-plaintext highlighter-rouge">minmax()</code> or the <code class="language-plaintext highlighter-rouge">maxmin()</code> method of the <code class="language-plaintext highlighter-rouge">Model</code> object to specify the objective function and the uncertainty set.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>minmax(obj, *args) method of rsome.ro.Model instance
    Minimize the maximum objective value over the given uncertainty set.

    Parameters
    ----------
    obj
        Objective function involving random variables
    *args
        Constraints or collections of constraints of random variables
        used for defining the uncertainty set

    Notes
    -----
    The uncertainty set defined for the objective function is considered
    the default uncertainty set for the robust model.
</code></pre></div></div>
<p>The documentation shows that the objective function of the robust model is specified by the first argument <code class="language-plaintext highlighter-rouge">obj</code>, while the remaining arguments could be constraints, or collection of constraints, used for defining the uncertainty set. The <code class="language-plaintext highlighter-rouge">minmax()</code> and <code class="language-plaintext highlighter-rouge">maxmin()</code> methods thus enable two approaches for specifying the worst-case objective, as shown by the sample code below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>
<span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>   

<span class="n">x</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">dvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                <span class="c1"># 5 decision variables as a 1D array
</span><span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>                <span class="c1"># 5 random variables as a 1D array
</span>
<span class="c1"># define the uncertainty set z_set0 as a tuple
</span><span class="n">z_set0</span> <span class="o">=</span> <span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span>   
          <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># the worst-case objective over the uncertainty set z_set0
</span><span class="n">model</span><span class="p">.</span><span class="n">minmax</span><span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">z</span><span class="p">,</span> <span class="n">z_set0</span><span class="p">)</span>    

<span class="c1"># the worst-case objective over an uncertainty set defined by two constraints
</span><span class="n">model</span><span class="p">.</span><span class="n">minmax</span><span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">z</span><span class="p">,</span> <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="n">inf</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.25</span><span class="p">)</span>
</code></pre></div></div>

<p>Similar to deterministic constraints, the worst-case constraints can be defined using the NumPy-style array operations, and the associated uncertainty set is specified using the <code class="language-plaintext highlighter-rouge">forall()</code> method of the constraint.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forall(*args) method of rsome.lp.RoConstr instance
    Specify the uncertainty set of the constraints involving random
    variables. The given arguments are constraints or collections of
    constraints used for defining the uncertainty set.

    Notes
    -----
    The uncertainty set defined by this method overrides the default
    uncertainty set defined for the worst-case objective.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">forall()</code> method enables users to flexibly define the worst-case constraints, as demonstrated by the sample code below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>
<span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>   

<span class="n">x</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">dvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># define an ellipsoidal uncertainty set z_set0
</span><span class="n">z_set0</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.5</span>

<span class="c1"># the worst-case objective over the uncertainty set z_set0
</span><span class="n">model</span><span class="p">.</span><span class="n">minmax</span><span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">z</span><span class="p">,</span> <span class="n">z_set0</span><span class="p">)</span>    

<span class="c1"># worst-case constraints over the uncertainty set z_set0
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">).</span><span class="n">forall</span><span class="p">(</span><span class="n">z_set0</span><span class="p">))</span>      
<span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">((</span><span class="n">x</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">).</span><span class="n">forall</span><span class="p">(</span><span class="n">z_set0</span><span class="p">))</span>        

<span class="c1"># worst-case constraints over different uncertainty sets defined by a loop
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[:</span><span class="n">i</span><span class="p">].</span><span class="nb">sum</span><span class="p">()).</span><span class="n">forall</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div></div>

<p>Note that if the uncertainty set of a robust constraint is unspecified, then by default, its uncertainty set is \(\mathcal{Z}_0\), defined by the <code class="language-plaintext highlighter-rouge">minmax()</code> or <code class="language-plaintext highlighter-rouge">maxmin()</code> methods for the worst-case objective. The sample code above is hence equivalent to the following code segment.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>
<span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">norm</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>   

<span class="n">x</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">dvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># define an ellipsoidal uncertainty set z_set0
</span><span class="n">z_set0</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1.5</span>

<span class="c1"># the worst-case objective over the default uncertainty set z_set0
</span><span class="n">model</span><span class="p">.</span><span class="n">minmax</span><span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">z</span><span class="p">,</span> <span class="n">z_set0</span><span class="p">)</span>    

<span class="c1"># worst-case constraints over the default uncertainty set z_set0
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span>      
<span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">z</span> <span class="o">+</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>        

<span class="c1"># worst-case constraints over uncertainty sets different from the default one
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">((</span><span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">[:</span><span class="n">i</span><span class="p">].</span><span class="nb">sum</span><span class="p">()).</span><span class="n">forall</span><span class="p">(</span><span class="n">norm</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="o">*</span><span class="mf">0.5</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
</code></pre></div></div>

<p>The sample code above shows that the Python version of RSOME is able to specify different uncertainty sets \(\mathcal{Z}_m\), \(m\in\mathcal{M}_1\cup\{0\}\), for the objective function (with index 0) and each of the constraints (with index \(m\in\mathcal{M}_1\)).  Such a framework is more flexible than that in the MATLAB version introduced in <a href="#ref2">Chen et al.  (2020)</a> and can be used to address a rich range of robust models, including the distributional interpretation of robust
formulation in <a href="#ref4">Xu et al. (2012)</a>, the notion of Pareto robustly optimal solution discussed in <a href="#ref3">de Ruiter et al. (2016)</a>, as well as the sample robust optimization models proposed by <a href="#ref1">Bertsimas et al. (2021)</a>.</p>

<h2 id="linear-decision-rules-for-adaptive-decision-making-">Linear Decision Rules for Adaptive Decision-Making <a name="section2.4"></a></h2>

<p>The <code class="language-plaintext highlighter-rouge">rsome.ro</code> modeling environment also supports linear decision rules for non-anticipative decision-making. A linear decision rule object can be created by the <code class="language-plaintext highlighter-rouge">ldr()</code> method of an <code class="language-plaintext highlighter-rouge">ro</code> model. Details of the method are provided below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ldr(shape=(1,), name=None) method of rsome.ro.Model instance
    Returns an array with the given shape of linear decision rule
    variables.

    Parameters
    ----------
    shape : int or tuple
        Shape of the variable array.
    name : str
        Name of the variable array

    Returns
    -------
    new_var : rsome.ro.DecRule
        An array of new linear decision rule variables
</code></pre></div></div>

<p>Decision rules are also defined as arrays, as shown by the following examples.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">ldr</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>       <span class="c1"># 2x4 decision rule variables as a 2D array
</span><span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">ldr</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>    <span class="c1"># 3x5x4 decision rule variables as a 3D array
</span>
<span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2x4 decision rule variables
3x5x4 decision rule variables
</code></pre></div></div>

<p>As mentioned in previous sections, the decision rule \(y_i\) is restricted to being affinely depend on a subset \(\mathcal{J}_i\) of random variables, and such a subset can be specified by the <code class="language-plaintext highlighter-rouge">adapt()</code> method of the decision rule object, as shown by the following code segment.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>      <span class="c1"># 2x4 random variables as a 2D array
</span><span class="n">u</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>           <span class="c1"># 5 random variables as a 1D array
</span>
<span class="n">x</span><span class="p">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>                  <span class="c1"># all elements of x depends on all z elements
</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="p">:].</span><span class="n">adapt</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># y[2, 3:, :] depends on z[0, 1]
</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="p">:].</span><span class="n">adapt</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>    <span class="c1"># y[1, 3:, :] depends on u[3:]
</span></code></pre></div></div>

<p>Once the decision rules are created and the affine dependency on random variables is specified, the aforementioned array operations and syntax can be applied to decision rule arrays in constructing constraints involving adaptive decisions. The affine dependency must be specified before using decision rule variables in constraints, otherwise an error message will be given.</p>

<p>Finally, after the model is solved, coefficients of a decision rule <code class="language-plaintext highlighter-rouge">y</code> could be accessed by the <code class="language-plaintext highlighter-rouge">get()</code> method. More specifically:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">y.get()</code> returns the constant coefficients of the decision rule <code class="language-plaintext highlighter-rouge">y</code>. The returned array has the same shape as the decision rule array <code class="language-plaintext highlighter-rouge">y</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">y.get(z)</code> returns the linear coefficients of <code class="language-plaintext highlighter-rouge">y</code> with respect to the random variable <code class="language-plaintext highlighter-rouge">z</code>. The shape of the returned array is <code class="language-plaintext highlighter-rouge">y.shape + z.shape</code>, <i>i.e.</i>, the combination of dimensions of <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>. For example, if <code class="language-plaintext highlighter-rouge">c = y.get(z)</code> where <code class="language-plaintext highlighter-rouge">y.dim=2</code> and <code class="language-plaintext highlighter-rouge">z.dim=2</code>, the returned coefficients are presented as a four-dimensional array <code class="language-plaintext highlighter-rouge">c</code> and <code class="language-plaintext highlighter-rouge">c[i, j]</code> gives the linear coefficients of <code class="language-plaintext highlighter-rouge">y[i, j]</code> with respect to the random variable <code class="language-plaintext highlighter-rouge">z</code>.</li>
</ul>

<h2 id="solution-analysis-">Solution Analysis <a name="section2.5"></a></h2>

<p>After an RSOME model is successfully solved, affine or convex (concave) expressions of decision variables can be evaluated under the optimal solution as callable functions. Consider the adaptive robust optimization model below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">rsome</span> <span class="kn">import</span> <span class="n">ro</span>
<span class="kn">import</span> <span class="nn">rsome</span> <span class="k">as</span> <span class="n">rso</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">ro</span><span class="p">.</span><span class="n">Model</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">dvar</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>              <span class="c1"># x is a here-and-now decision
</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">rvar</span><span class="p">()</span>               <span class="c1"># z is a random variable
</span><span class="n">uset</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>        <span class="c1"># uncertainty set
</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">ldr</span><span class="p">()</span>                <span class="c1"># y is an affine decision rule
</span><span class="n">y</span><span class="p">.</span><span class="n">adapt</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>                     <span class="c1"># y affinely adapts to z
</span>
<span class="n">obj</span> <span class="o">=</span> <span class="n">c</span><span class="o">@</span><span class="n">x</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">y</span>                <span class="c1"># objective function
</span>
<span class="n">model</span><span class="p">.</span><span class="n">maxmin</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">uset</span><span class="p">)</span>        <span class="c1"># define the objective function
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">(</span><span class="n">rso</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># define a constraint
</span><span class="n">model</span><span class="p">.</span><span class="n">st</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">z</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span>         <span class="c1"># define another constraint
</span>
<span class="n">model</span><span class="p">.</span><span class="n">solve</span><span class="p">()</span>                  <span class="c1"># solve the model using the default solver
</span></code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Being solved by the default LP solver...
Solution status: 0
Running time: 0.0044s
</code></pre></div></div>

<p>Apparently, the optimal solution of <code class="language-plaintext highlighter-rouge">x</code> is an array \((0, 0, -1)\), and in the following code segment, expressions <code class="language-plaintext highlighter-rouge">lin_expr</code>, <code class="language-plaintext highlighter-rouge">abs_expr</code>, and <code class="language-plaintext highlighter-rouge">norm_expr</code> are callable functions and their values are evaluated under the optimal value of <code class="language-plaintext highlighter-rouge">x</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lin_expr</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">-</span> <span class="n">x</span><span class="p">.</span><span class="nb">sum</span><span class="p">()</span>        <span class="c1"># a linear expression of x 
</span><span class="n">abs_expr</span> <span class="o">=</span> <span class="mf">5.0</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="nb">sum</span><span class="p">())</span>   <span class="c1"># an expression of absolute values
</span><span class="n">norm_expr</span> <span class="o">=</span> <span class="n">rso</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>      <span class="c1"># a one-norm expression
</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">lin_expr</span><span class="p">()</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">abs_expr</span><span class="p">()</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">norm_expr</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>6.0, 4.0, 1.0
</code></pre></div></div>

<p>As a special case, <code class="language-plaintext highlighter-rouge">x()</code> is equivalent to <code class="language-plaintext highlighter-rouge">x.get()</code>, which returns the optimal value of <code class="language-plaintext highlighter-rouge">x</code>.</p>

<p>Affine expressions of decision rules or expressions involving random variables can also be evaluated as similar callable functions. The only difference is that values of such expressions are also affected by the involved random variables, so we may need to specify the realizations of random variables in calling these functions. For example, the optimal decision rule <code class="language-plaintext highlighter-rouge">y</code> in the model above can be written as \(y = z + 2.5\), its value under \(z=0.5\) is evaluated using the following code,</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">y</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)))</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.0
</code></pre></div></div>

<p>where the realization of a random variable is specified by the <code class="language-plaintext highlighter-rouge">assign()</code> method. The similar approach can be applied to <code class="language-plaintext highlighter-rouge">obj</code>, an affine expression of <code class="language-plaintext highlighter-rouge">y</code>, as shown below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">obj</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)))</span>    <span class="c1"># The value of obj = c@x + 2*y when z = 1.5
</span></code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>8.3
</code></pre></div></div>

<p>If the realization of a random variable is unspecified, its value is assumed to be zero by default in evaluating the expressions. As a result, <code class="language-plaintext highlighter-rouge">y()</code> is equivalent to <code class="language-plaintext highlighter-rouge">y.get()</code> as they both return the constant term of the optimal decision rule.</p>

<h2 id="application-examples-">Application Examples <a name="section2.6"></a></h2>

<h3 id="robust-portfolio"><a href="example_ro_portfolio">Robust Portfolio</a></h3>
<h3 id="conditional-value-at-risk-in-robust-portfolio-management"><a href="example_ro_cvar_portfolio">Conditional Value-at-Risk in Robust Portfolio Management</a></h3>
<h3 id="robustrobustness-knapsack"><a href="example_ro_knapsack">Robust/Robustness Knapsack</a></h3>
<h3 id="adaptive-robust-lot-sizing"><a href="example_ls">Adaptive Robust Lot-Sizing</a></h3>
<h3 id="joint-production-inventory"><a href="example_ro_inv">Joint Production-Inventory</a></h3>
<h3 id="robust-vehicle-pre-allocation"><a href="example_ro_vehicle">Robust Vehicle Pre-Allocation</a></h3>

<h2 id="reference">Reference</h2>

<p><a id="ref1"></a></p>

<p>Bertsimas, Dimitris, Shimrit Shtern, and Bradley Sturt. 2021. <a href="https://pubsonline.informs.org/doi/abs/10.1287/opre.2020.2096">Technical Note–Two-stage sample robust optimization</a>. <i>Operations Research</i> <b>70</b>(1) 624-640.</p>

<p><a id="ref2"></a></p>

<p>Chen, Zhi, Melvyn Sim, Peng Xiong. 2020. <a href="https://pubsonline.informs.org/doi/abs/10.1287/mnsc.2020.3603">Robust stochastic optimization made easy with RSOME</a>. <i>Management Science</i> <b>66</b>(8) 3329–3339.</p>

<p><a id="ref3"></a>
de Ruiter, Frans JCT, Ruud CM Brekelmans, and Dick den Hertog. 2016. <a href="https://link.springer.com/article/10.1007/s10107-016-0978-6">The impact of the existence of multiple adjustable robust solutions</a>. <i>Mathematical Programming</i> <b>160</b>(1) 531-545.</p>

<p><a id="ref4"></a>
Xu, Huan, Constantine Caramanis, and Shie Mannor. 2012. <a href="https://pubsonline.informs.org/doi/abs/10.1287/moor.1110.0531">A distributional interpretation of robust optimization</a>. <i>Mathematics of Operations Research</i> <b>37</b>(1) 95-110.</p>


      </section>
      <footer>
        
        <p>Maintained by <a href="https://github.com/XiongPengNUS">XiongPengNUS</a></p>
        
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>


  
  </body>
</html>
